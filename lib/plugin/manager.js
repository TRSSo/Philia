import fs from"node:fs/promises";import Path from"node:path";import schedule from"node-schedule";import{makeLogger}from"#logger";import{chalk}from"#util";export default class PluginManager{project;loaded=!1;path;ctx;command=[];middleware=[];event=[];schedule=[];start=[];stop=[];connect=[];close=[];constructor(e,n){this.project=e,this.ctx={logger:makeLogger(`Plugin`),ctx_map:e.ctx_map},this.path=Array.isArray(n)?n:[n]}async load(){if(this.loaded)throw Error(`插件加载已完成`);this.loaded=!0;let e=(await Promise.all(this.path.map(this.readdir.bind(this)))).flat().sort((e,n)=>e.priority-n.priority);for(let n of e)try{n.logger=this.makeLogger(this.ctx.logger,n.name);for(let e of[`command`,`middleware`,`event`])if(n[e])for(let r of n[e])this[e].push({...r,plugin:n});for(let e of[`start`,`stop`,`connect`,`close`])n[e]&&this[e].push(n);if(n.schedule)for(let e of n.schedule)this.schedule.push({...e,job:schedule.scheduleJob(e.spec,this.execSchedule.bind(this,n,e))})}catch(e){this.ctx.logger.error(`插件加载错误`,n,e)}}async readdir(r){try{let i=[];for(let a of await fs.readdir(r,{withFileTypes:!0}))a.isFile()&&a.name.endsWith(`.js`)&&i.push(this.import(Path.join(a.parentPath,a.name)));return(await Promise.all(i)).flat()}catch(e){this.ctx.logger.error(`文件夹读取错误 ${chalk.red(r)}`,e)}return[]}async import(e){let n=[];try{let r=await import(`file://${e}`);for(let e in r)typeof r[e]?.plugin==`object`&&n.push(r[e].plugin)}catch(n){this.ctx.logger.error(`插件加载错误 ${chalk.red(e)}`,n)}return n}makeLogger(e,n){return n=chalk.cyan(`[${n}]`),Object.setPrototypeOf({trace:e.trace.bind(e,n),debug:e.debug.bind(e,n),info:e.info.bind(e,n),warn:e.warn.bind(e,n),error:e.error.bind(e,n),fatal:e.fatal.bind(e,n),mark:e.mark.bind(e,n)},e)}async execSchedule(e,n){try{e.logger.debug(`定时任务开始执行`),await n.method({...this.ctx,logger:e.logger}),e.logger.debug(`定时任务执行完成`)}catch(n){e.logger.error(`定时任务执行错误`,n)}}exec(e,n,r,...i){return Promise.all(r.map(async r=>{i[0]={...i[0],logger:r.logger};try{await r[n](...i)}catch(n){r.logger.error(e,n)}}))}execStart(){return this.exec(`开启插件错误`,`start`,this.start,this.ctx)}execStop(){return this.exec(`关闭插件错误`,`stop`,this.stop,this.ctx)}execConnect(...e){return this.exec(`机器人连接插件错误`,`connect`,this.connect,...e)}execClose(...e){return this.exec(`机器人断开插件错误`,`close`,this.close,...e)}}