import*as Philia from"#project/project/philia.js";import{createAPI,EventHandle}from"#protocol/common";import{makeError}from"#util";import*as Convert from"./convert/index.js";export default class Client{logger;philia;url;ws;timeout=6e4;open=!1;api=createAPI(this);handle=new Convert.API(this);event=new Convert.Event(this);event_handle;constructor(n,i,a){this.logger=n,this.philia=new Philia.Project(i,this.handle),this.event_handle=new EventHandle(this.philia),this.url=a instanceof URL?a:new URL(a)}event_promise;promiseEvent(){return this.event_promise?this.event_promise.promise:(this.event_promise=Promise.withResolvers(),this.event_promise.promise.finally(()=>this.event_promise=void 0))}start(){if(this.open===!0)return Promise.resolve();this.reconnect_delay||=5e3;let e=new URL(this.url);return e.pathname+=`event`,this.ws=new WebSocket(e),this.logger.info(`WebSocket 正在连接 ${this.ws.url}`),this.ws.onopen=e=>{this.open=!0,this.reconnect_delay=5e3,this.event_promise?.resolve(e),this.logger.info(`WebSocket 已连接 ${this.ws.url}`),this.philia.start()},this.ws.onerror=e=>{this.logger.error(`WebSocket 错误`,e)},this.ws.onclose=e=>{this.open=!1,this.logger.info(`WebSocket 已断开 ${e.reason}(${e.code})`),this.philia.stop(),this.reconnect()},this.ws.onmessage=this.message.bind(this),this.promiseEvent()}reconnect_delay=5e3;reconnect_timeout;reconnect(){if(!this.reconnect_delay)return this.event_promise?.reject();this.logger.info(`WebSocket ${this.reconnect_delay/1e3} 秒后重连`),this.reconnect_timeout=setTimeout(this.start.bind(this),this.reconnect_delay),this.reconnect_delay+=5e3}close(){return this.open?(this.reconnect_delay=0,this.ws.close(),this.promiseEvent().catch(()=>{})):(clearTimeout(this.reconnect_timeout),Promise.resolve())}async message(e){try{let n=JSON.parse(e.data.toString());this.logger.trace(`WebSocket 消息`,n),this.event_handle.handle(await this.event.convert(n))}catch(n){this.logger.error(`WebSocket 消息解析错误`,e,n)}}async request(e,n={}){let r=new URL(this.url);r.pathname+=`api/${e}`,this.logger.trace(`HTTP 请求`,e,n);let a=await(await fetch(r,{method:`POST`,body:JSON.stringify(n),signal:AbortSignal.timeout(this.timeout)})).json();if(this.logger.trace(`HTTP 返回`,e,a),a.retcode!==0)throw makeError(a.message,{request:{name:e,data:n},response:a});return a.data}}