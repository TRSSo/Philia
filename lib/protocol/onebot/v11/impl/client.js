import{ulid}from"ulid";import{WebSocket}from"ws";import*as Philia from"#project/project/philia.js";import{createAPI,EventHandle}from"#protocol/common";import{makeError,promiseEvent,toJSON}from"#util";import*as Convert from"../convert/index.js";import Protocol from"./protocol.js";export default class Client{logger;philia;ws;path;api=createAPI(this);handle=new Convert.API.PhiliaToOBv11(this);protocol=new Protocol(this);event_handle;cache=new Map;queue=[];timeout=6e4;get open(){return this.ws.readyState===WebSocket.OPEN||this.ws.readyState===WebSocket.CLOSING}constructor(e,a,s,c){this.logger=e,this.philia=new Philia.Project(a,this.handle),this.event_handle=new EventHandle(this.philia),s instanceof WebSocket?(this.ws=s,this.philia.start()):(this.path=s,this.logger.info(`WebSocket 正在连接 ${s}`),this.ws=new WebSocket(s,c),this.ws.onopen=async()=>{this.logger.info(`WebSocket 已连接 ${s}`),await this.philia.start(),this.sendQueue()}),this.listener()}listener(){this.ws.onerror=e=>{this.logger.error(`WebSocket 错误`,e)},this.ws.onclose=e=>{this.logger.info(`WebSocket 已断开 ${e.reason}(${e.code})`),this.philia.stop(),this.cache.forEach(e=>{clearTimeout(e.timeout)})},this.ws.onmessage=this.message.bind(this)}close(){return this.ws.close(),promiseEvent(this.ws,`close`,`error`)}async message(e){try{let r=JSON.parse(e.data.toString());this.logger.trace(`WebSocket 消息`,r),await this.protocol.handle(r)}catch(r){this.logger.error(`WebSocket 消息解析错误`,e.data,r)}}sendQueue(){if(!(this.queue.length&&this.open))return;let e=this.cache.get(this.queue.shift())?.request;return e&&(this.logger.trace(`WebSocket 发送`,e),this.ws.send(JSON.stringify(e))),this.sendQueue()}request(r,i={}){let a=ulid(),o={action:r,params:i,echo:a};this.logger.trace(`WebSocket 请求`,o),this.open?this.ws.send(toJSON(o)):this.queue.push(a);let{promise:c,resolve:l,reject:u}=Promise.withResolvers();return this.cache.set(a,{promise:c,resolve:l,reject:u,request:o,timeout:setTimeout(()=>{u(makeError(`WebSocket 请求超时`,o,{timeout:this.timeout})),this.logger.error(`WebSocket 请求超时`,o),this.close()},this.timeout)}),c.catch(e=>{throw makeError(e.msg||e.wording,o,{error:e})}).finally(()=>{clearTimeout(this.cache.get(a)?.timeout),this.cache.delete(a)})}}