import{isPromise}from"node:util/types";import{getAllProps,Loging,makeError,toJSON}from"#util";import*as type from"./type.js";export default class Handle{client;default_handle=[[`heartbeat`,()=>{}],[`getHandleList`,()=>Array.from(this.map.keys())],[`default`,e=>{throw new type.CError(`NotFoundError`,`处理器 ${e} 不存在`)}]];map=new Map(this.default_handle);reply_cache={};constructor(e,n){this.client=n,this.setMap(e)}set(...e){return this.map.set(...e)}setMap(e){for(let r of getAllProps(e))typeof e[r]==`function`&&this.set(r,e[r].bind(e))}setOnce(e,n){return this.map.set(e,(...r)=>(this.map.delete(e),typeof n==`function`?n(...r):n))}del(e){return Array.isArray(e)?e.map(this.map.delete.bind(this.map)):this.map.delete(e)}clear(){this.map=new Map(this.default_handle)}data(e){switch(this.client.logger.trace(`接收`,e),e.code){case 0:return this.reply_cache[e.id]?this.client.send(this.reply_cache[e.id]):this.request(e,this.reply.bind(this,e));case 1:return this.response(e);case 2:return this.async(e);case 3:return this.error(e);default:throw TypeError(`不支持的数据类型`)}}reply(e,n,r){return this.reply_cache[e.id]={id:e.id,code:n,data:r},n!==2&&setTimeout(()=>delete this.reply_cache[e.id],this.client.timeout.idle),this.client.send(this.reply_cache[e.id])}async request(n,i){try{let a=this.map.get(n.name),o;return a?typeof a==`function`?(this.client.logger.debug(`执行处理器 ${n.name}(${n.data===void 0?``:Loging(n.data)})`),o=a(n.data,this.client)):(this.client.logger.debug(`得到值 ${n.name} => ${Loging(a)}`),o=a):(this.client.logger.debug(`执行默认处理器 (${Loging(n.name)}${n.data===void 0?``:`, ${Loging(n.data)}`})`),o=this.map.get(`default`)(n.name,n.data,this.client)),isPromise(o)&&(i(2),o=await o),i(1,o)}catch(e){let r={name:`HandleError`,message:`处理器 ${n.name} 错误: ${e}`};return e instanceof Error?(Object.assign(r,e),r.error=e.stack):e instanceof type.CError?r=e.data:r.error=toJSON(e),i(3,r)}}getCache(e){let n=this.client.cache[e.id];if(!n)throw makeError(`请求缓存 ${e.id} 不存在`,{req:e});return clearTimeout(n.timeout),n}response(e){let n=this.getCache(e);n.resolve(e.data)}async(e){let n=this.getCache(e);n.finally(),n.finally=()=>delete this.client.cache[e.id];let r=e.time?e.time*1e3:this.client.timeout.wait;this.client.setTimeout(n,r),this.client.cache[e.id]=n}error(e){let n=this.getCache(e);n.reject(makeError(e.data.message,{...e.data,request:n.data}))}}