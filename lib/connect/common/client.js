import{ulid}from"ulid";import{makeError,promiseEvent}from"#util";import{compress,Encoder,encoder,verify}from"./encoder.js";import Handle from"./handle.js";export default class Client{logger;handle;timeout={send:5e3,wait:6e4,idle:3e5,retry:3};meta={local:{id:ulid(),name:`Client`,version:1,encode:Array.from(encoder.keys()),verify:Array.from(verify.keys())}};encoder;cache=new Map;queue=[];idle=!1;open=!1;path=``;constructor(e,a,o={}){this.logger=e,this.handle=new Handle(a,this),o.meta&&Object.assign(this.meta.local,o.meta),o.timeout&&Object.assign(this.timeout,o.timeout),o.compress?this.meta.local.verify.unshift(...Array.from(compress.keys())):this.meta.local.verify.push(...Array.from(compress.keys())),o.connected_fn&&(this.connected_fn=o.connected_fn),o.closed_fn&&(this.closed_fn=o.closed_fn)}connect(e,a){if(this.open)throw Error(`连接已打开`);if(e)this.path=e;else if(this.path)e=this.path;else throw Error(`连接地址为空`);return this.connectOpen(e),this.onconnectError(a)}send(e){return`data`in e&&e.data===void 0&&delete e.data,this.logger.trace(`发送`,e),this.write(this.encoder.encode(e))}async onconnect(){try{if(this.meta.remote=await this.getMetaInfo(),this.meta.local.version!==this.meta.remote.version)throw makeError(`协议版本不支持`,this.meta);for(let e in this.encoder=new Encoder(this.meta.local,this.meta.remote),this.listener)this.event.on(e,this.listener[e]);this.event.emit(`connected`,this)}catch(e){if(this.path)this.event.emit(`error`,e);else throw e}}onconnected(e=``){this.open=!0,this.sender(),this.connected_fn?.(this),e&&=`，${e}`,this.path?this.logger.debug(`${this.meta.remote?.id} 已连接`,this.meta.remote):(this.logger.info(`${this.meta.remote?.id} 已连接${e}`),this.logger.debug(this.meta.remote))}onconnectError(e){if(e===0)return promiseEvent(this.event,`connected`,`error`);this.reconnect_allow=!0,promiseEvent(this.event,`connected`,`error`).catch(a=>{this.logger.error(`连接错误`,a),this.reconnect(e)})}reconnect_allow=!1;reconnect_timeout;reconnect(e=this.timeout.send){this.reconnect_allow&&(this.logger.info(e/1e3,`秒后重连`),this.reconnect_timeout=setTimeout(this.connect.bind(this,void 0,e+this.timeout.send),e))}prepareClose(){this.reconnect_allow=!1,clearTimeout(this.reconnect_timeout)}onclose(e=``){for(let e in this.open=!1,this.listener)this.event.off(e,this.listener[e]);this.closed_fn?.(this),this.cache.forEach((e,a)=>{e.finally=this.cache.delete.bind(this.cache,a),clearTimeout(e.timeout),e.timeout=setTimeout(()=>e.reject(Error(`连接断开`)),this.timeout.wait)}),e=`${this.meta.remote?.id} 已断开连接${e&&`，${e}`}`,this.path&&this.reconnect_allow?(this.logger.warn(e),this.reconnect()):this.logger.debug(e)}onerror(e){this.logger.error(`错误`,e),this.forceClose()}setTimeout(e,o){e.timeout=setTimeout(()=>{if(e.retry>this.timeout.retry)return e.reject(makeError(`等待消息超时`,{timeout:o}));e.retry++,this.logger.warn(`发送 ${e.data.id} 超时，重试${e.retry}次`),o?(this.queue.push(e.data.id),this.idle&&(this.idle=!1,this.sender())):(this.queue.unshift(e.data.id),this.idle=!1,this.sender())},o??this.timeout.send)}sender(){if(!this.open)return this.idle=!0;let e=this.queue.shift();if(!e)return this.idle=!0;let a=this.cache.get(e);if(!a?.data)return this.sender();this.setTimeout(a),this.send(a.data)}request(a,o){let s=ulid(),c={data:{id:s,code:0,name:a,data:o},retry:0,finally:()=>{this.cache.delete(s),this.sender()},...Promise.withResolvers()};return this.cache.set(s,c),this.queue.push(s),this.idle&&(this.idle=!1,this.sender()),c.promise.finally(()=>c.finally())}}