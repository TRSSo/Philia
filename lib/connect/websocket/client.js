import{WebSocket}from"ws";import{makeError,promiseEvent,StringOrBuffer}from"#util";import{Encoder}from"../common/encoder.js";import{Client as AClient}from"../common/index.js";export default class Client extends AClient{event;ws_opts;constructor(n,r,i={}){for(let a in super(n,r,{compress:!0,...i}),i.path&&(this.path=i.path),i.ws instanceof WebSocket?this.event=i.ws:this.ws_opts=i.ws,this.listener)this.listener[a]=this.listener[a].bind(this)}connectOpen(n){this.event=new WebSocket(n,this.ws_opts).on(`open`,this.onconnect.bind(this))}heartbeat_timeout;heartbeat=()=>{this.heartbeat_timeout=setTimeout(()=>this.request(`heartbeat`).then(this.heartbeat).catch(this.forceClose),this.timeout.idle)};onclose(e){clearTimeout(this.heartbeat_timeout),super.onclose(e)}listener={message:this.receive,connected(){this.onconnected(),this.heartbeat()},close(){this.onclose()},error:this.onerror};getMetaInfo(){return this.encoder=new Encoder,this.write(this.encoder.encode(this.meta.local)),new Promise((e,r)=>{let a=a=>{try{e(this.encoder.decode(a))}catch(e){r(makeError(`解析元数据错误`,{data:StringOrBuffer(a),cause:e}))}clearTimeout(o)},o=setTimeout(()=>{r(makeError(`等待元数据超时`,{timeout:this.timeout.send})),this.event.off(`message`,a)},this.timeout.send);this.event.once(`message`,a)})}forceClose=()=>{this.prepareClose(),this.event.terminate()};close(){this.prepareClose(),this.event.close();let e=setTimeout(this.forceClose,this.timeout.wait);return promiseEvent(this.event,`close`,`error`).finally(()=>clearTimeout(e))}write(e){return this.event.send(e)}receive(e){try{this.handle.data(this.encoder.decode(e))}catch(r){throw this.close(),makeError(`处理数据错误`,{data:e,cause:r})}}}