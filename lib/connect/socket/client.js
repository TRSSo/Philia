import{Socket}from"node:net";import os from"node:os";import Path from"node:path";import{makeError,promiseEvent,StringOrBuffer}from"#util";import{Encoder}from"../common/encoder.js";import{Client as AClient}from"../common/index.js";export default class Client extends AClient{event;buffer;buffer_split;constructor(i,a,o={}){for(let s in super(i,a,o),o.path&&(this.path=o.path),o.socket instanceof Socket?this.event=o.socket:this.event=new Socket(o.socket).on(`connect`,this.onconnect.bind(this)),this.event.setTimeout(this.timeout.idle),this.listener)this.listener[s]=this.listener[s].bind(this)}connectOpen(e){if(e.startsWith(`tcp://`)){let[i,a]=e.slice(6).split(`:`);this.event.connect(Number(a),i);return}switch(e=Path.resolve(e),os.type()){case`Linux`:e=`\0${e}`;break;case`Windows_NT`:e=Path.join(`\\\\?\\pipe`,e);break}this.event.connect(e)}onclose(e){this.buffer=Buffer.alloc(0),super.onclose(e)}listener={data:this.receive,connected(){this.onconnected()},end(){this.logger.debug(`${this.meta.remote?.id} 请求关闭`)},close(){this.onclose()},timeout(){this.request(`heartbeat`).catch(this.forceClose)},error:this.onerror};getMetaInfo(){return this.encoder=new Encoder,this.buffer=Buffer.alloc(0),this.write(this.encoder.encode(this.meta.local)),new Promise((e,i)=>{let a=c=>{try{this.buffer=Buffer.concat([this.buffer,c]);let i=this.decode();if(i===this.decode_empty)return;e(i)}catch(e){i(makeError(`解析元数据错误`,{data:StringOrBuffer(c),cause:e}))}clearTimeout(s),this.event.off(`data`,a)},s=setTimeout(()=>{i(makeError(`等待元数据超时`,{timeout:this.timeout.send})),this.event.off(`data`,a)},this.timeout.send);this.event.on(`data`,a)})}forceClose=()=>{this.prepareClose(),this.event.destroy()};close(){this.prepareClose(),this.event.end();let e=setTimeout(this.forceClose,this.timeout.wait);return promiseEvent(this.event,`close`,`error`).finally(()=>clearTimeout(e))}decode_empty=Symbol(`decode_empty`);decode(){if(this.buffer.length<4)return this.decode_empty;let e=this.buffer.readUint32BE()+4;if(this.buffer.length<e)return this.decode_empty;let i=this.buffer.subarray(4,e);return this.buffer_split&&=(i=Buffer.concat([this.buffer_split,i]),void 0),this.buffer=this.buffer.subarray(e),e===4294967299?(this.buffer_split=i,this.decode()):this.encoder.decode(i)}write(e){for(;e.length>=4294967295;){let i=Buffer.allocUnsafe(4);i.writeUint32BE(4294967295),this.event.write(Buffer.concat([i,e.subarray(0,4294967295)])),e=e.subarray(4294967295)}let i=Buffer.allocUnsafe(4);return i.writeUint32BE(e.length),this.event.write(Buffer.concat([i,e]))}receive(e){try{this.buffer=Buffer.concat([this.buffer,e]);let i;for(;(i=this.decode())!==this.decode_empty;)this.handle.data(i)}catch(i){throw this.close(),makeError(`处理数据错误`,{data:e,cause:i})}}}