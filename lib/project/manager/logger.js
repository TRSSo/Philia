import{Writable}from"node:stream";import{closeStdout,getLogger}from"#logger";import{promiseEvent,StringOrBuffer}from"#util";import{LoggerLevel}from"./type.js";const logger=getLogger(`Console`);for(let o of[process.stdout,process.stderr])promiseEvent(o,`close`,`error`).catch(()=>{}).finally(()=>{o===process.stdout&&closeStdout();let s=new Writable({write:o===process.stdout?(e,a,o)=>{StringOrBuffer(e,!0).trim().split(`
`).map(e=>logger.info(e)),o()}:(e,a,o)=>{StringOrBuffer(e,!0).trim().split(`
`).map(e=>logger.error(e)),o()}});o.write=s.write.bind(s),o.isTTY=!0});export default class LoggerManager{manager;logger;events=[];follows=[];config;constructor(e,a=getLogger()){this.manager=e,this.logger=a,this.config=e.config.logger,this.manager.logger.setHook(),this.logger.setHook(this.hook.bind(this))}hook(e,a,o){let s={name:e,time:Date.now(),level:LoggerLevel[a.levelStr],data:o};for(let e of this.follows)s.level>=e.level&&e.client.request(e.handle,s).catch(()=>{});this.events.length===this.config.max_lines&&this.events.unshift(),this.events.push(s)}get(e){let a=[];if(e.time&&e.time<0)for(let o=this.events.length-1;o>=0;o--){let s=this.events[o];if(!(s.level<e.level)&&(a.unshift(s),e.lines&&a.length===e.lines))break}else for(let o of this.events){if(o.level<e.level||e.time&&o.time<e.time)continue;if(a.push(o),e.lines&&a.length===e.lines)break}return a}follow(e,a){this.follows.some(e=>e.client===a)||a.event.once(`close`,this.unfollow.bind(this,a)),this.follows.push({...e,client:a})}unfollow(e){this.follows=this.follows.filter(a=>a.client!==e)}}